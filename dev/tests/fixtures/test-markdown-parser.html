<!DOCTYPE html>
<html>
<head>
    <title>Test Markdown Parser</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .output { border: 1px solid #ccc; padding: 20px; margin-top: 20px; background: #f5f5f5; }
        pre { background: #282c34; color: #abb2bf; padding: 10px; overflow-x: auto; }
        code { background: #e8e8e8; padding: 2px 4px; }
        .position-relative { position: relative; }
        .copy-code { position: absolute; top: 10px; right: 10px; }
    </style>
</head>
<body>
    <h1>Markdown Parser Test</h1>
    
    <div id="testContent" style="display:none">
# Test Heading

This is a **bold** text and this is *italic* text.

## Subheading

Here's a list:
- Item 1
- Item 2
- Item 3

### Code Example

```typescript
const example = "Hello World";
console.log(example);
```

Here's some `inline code` too.

---

Checkboxes:
- [ ] Task 1
- [x] Task 2

**Your Answer**: This is a test answer.
    </div>
    
    <div class="output" id="output"></div>
    
    <script>
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function decodeHtmlEntities(text) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = text;
            return textarea.value;
        }
        
        function parseMarkdown(text) {
            // First decode HTML entities
            text = decodeHtmlEntities(text);
            
            // Store code blocks with placeholders to protect them
            const codeBlocks = [];
            text = text.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                const index = codeBlocks.length;
                codeBlocks.push({
                    lang: lang || 'typescript',
                    code: code.trim()
                });
                return `__CODE_BLOCK_${index}__`;
            });
            
            // Store inline code to protect it
            const inlineCode = [];
            text = text.replace(/`([^`]+)`/g, (match, code) => {
                const index = inlineCode.length;
                inlineCode.push(code);
                return `__INLINE_CODE_${index}__`;
            });
            
            // Handle horizontal rules
            text = text.replace(/^---+$/gm, '<hr>');
            
            // Handle headers (must be done in order)
            text = text.replace(/^### (.+)$/gm, '<h4>$1</h4>');
            text = text.replace(/^## (.+)$/gm, '<h3>$1</h3>');
            text = text.replace(/^# (.+)$/gm, '<h2>$1</h2>');
            
            // Handle bold text (including multi-word)
            text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            
            // Handle italic text (avoid list markers)
            text = text.replace(/([^-*\s])\*([^*\n]+)\*/g, '$1<em>$2</em>');
            
            // Handle checkboxes
            text = text.replace(/^- \[ \] (.+)$/gm, '<div class="form-check"><input type="checkbox" disabled><label>$1</label></div>');
            text = text.replace(/^- \[x\] (.+)$/gm, '<div class="form-check"><input type="checkbox" checked disabled><label>$1</label></div>');
            
            // Process lists line by line
            const lines = text.split('\n');
            let processedLines = [];
            let inList = false;
            let listType = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                // Check for bullet points
                const bulletMatch = line.match(/^(\s*)[-*]\s+(.+)$/);
                const numberMatch = line.match(/^(\s*)\d+\.\s+(.+)$/);
                
                if (bulletMatch) {
                    const content = bulletMatch[2];
                    
                    if (!inList || listType !== 'ul') {
                        if (inList && listType === 'ol') {
                            processedLines.push('</ol>');
                        }
                        processedLines.push('<ul>');
                        inList = true;
                        listType = 'ul';
                    }
                    
                    processedLines.push(`<li>${content}</li>`);
                } else if (numberMatch) {
                    const content = numberMatch[2];
                    
                    if (!inList || listType !== 'ol') {
                        if (inList && listType === 'ul') {
                            processedLines.push('</ul>');
                        }
                        processedLines.push('<ol>');
                        inList = true;
                        listType = 'ol';
                    }
                    
                    processedLines.push(`<li>${content}</li>`);
                } else {
                    // Not a list item
                    if (inList && trimmedLine === '') {
                        // Empty line might end the list
                        processedLines.push(`</${listType}>`);
                        inList = false;
                        listType = null;
                    } else if (trimmedLine !== '') {
                        // Close list if we hit non-empty non-list content
                        if (inList) {
                            processedLines.push(`</${listType}>`);
                            inList = false;
                            listType = null;
                        }
                        // Wrap non-empty lines in paragraphs
                        processedLines.push(`<p>${line}</p>`);
                    } else {
                        // Empty line
                        processedLines.push('');
                    }
                }
            }
            
            // Close any open list
            if (inList) {
                processedLines.push(`</${listType}>`);
            }
            
            text = processedLines.join('\n');
            
            // Clean up multiple empty paragraphs
            text = text.replace(/<p>\s*<\/p>/g, '');
            
            // Restore inline code
            inlineCode.forEach((code, index) => {
                text = text.replace(`__INLINE_CODE_${index}__`, `<code>${escapeHtml(code)}</code>`);
            });
            
            // Restore code blocks
            codeBlocks.forEach((block, index) => {
                const codeHtml = `
<div class="position-relative">
    <button class="copy-code">Copy</button>
    <pre><code class="language-${block.lang}">${escapeHtml(block.code)}</code></pre>
</div>`;
                text = text.replace(`__CODE_BLOCK_${index}__`, codeHtml);
            });
            
            return text;
        }
        
        // Test the parser
        const testContent = document.getElementById('testContent').textContent;
        const output = parseMarkdown(testContent);
        document.getElementById('output').innerHTML = output;
        
        console.log('Input:', testContent);
        console.log('Output:', output);
    </script>
</body>
</html>